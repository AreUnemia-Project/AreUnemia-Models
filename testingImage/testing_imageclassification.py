# -*- coding: utf-8 -*-
"""Anemia_2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QWkIis3CVFY_MiZ_hsK1gvE9szYrFmkj
"""

import numpy as np
import cv2 as cv
import os
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from keras.models import Sequential
from keras.layers import Conv2D,Dropout,Flatten,Dense,MaxPool2D
from sklearn.metrics import classification_report,confusion_matrix,accuracy_score
import warnings
import tensorflowjs as tfjs

warnings.filterwarnings('ignore')

from google.colab import drive

Categories = ["anemia", "non-anemia"]

data_dir = '../trainingImage/Anemia-Classification'

data = []
for category in Categories:
    path = os.path.join(data_dir, category)
    class_num = Categories.index(category)
    for img in os.listdir(path):
        img_path = os.path.join(path, img)
        img_arr = cv.imread(img_path)
        if img_arr is not None:
            re = cv.resize(img_arr, (64, 64))
            data.append([re, class_num])
        else:
            print(f"Failed to load image: {img_path}")

np.random.shuffle(data)

x_data = []
y_data = []
for features,labels in data:
  x_data.append(features)
  y_data.append(labels)

x_data = np.array(x_data)
y_data = np.array(y_data)

print (f"shape of x data {x_data.shape}")
print (f"shape of y data {y_data.shape}")

y_data

x_data = x_data/255.0

unique_values, value_counts = np.unique(y_data, return_counts=True)

# Create the bar chart
plt.bar(unique_values, value_counts)

# Add labels and title
plt.xlabel('Unique Values')
plt.ylabel('Counts')
plt.title('Bar Chart of Unique Values')
plt.xticks(unique_values)

# Show the plot
plt.show()

plt.figure(figsize = (15,10))
for i in range (8) :
  plt.subplot(4,4,i+1)
  plt.imshow(x_data[i],cmap='gray')
  plt.axis("off")

x_train,x_test,y_train,y_test = train_test_split(x_data,y_data,test_size=0.2,random_state=22)

print(f"shape of x train {x_train.shape}")
print(f"shape of y train {y_train.shape}")
print(f"shape of x test {x_test.shape}")
print(f"shape of y test {y_test.shape}")

y_train

y_test

model = Sequential()
model.add(Conv2D(100, (3,3), input_shape = (64,64,3), activation = 'relu'))
model.add(MaxPool2D(2,2))
model.add(Conv2D(150, (3,3), activation = 'relu'))
model.add(MaxPool2D(2,2))
model.add(Flatten())
model.add(Dense(100, activation = 'relu'))
model.add(Dense(2, activation = 'sigmoid'))

model.compile (optimizer='adam', loss = 'sparse_categorical_crossentropy', metrics = ['accuracy'])

history = model.fit(x_train,y_train, validation_data = (x_test, y_test), batch_size = 20, epochs = 10)

model.summary()

y_pred = model.predict(x_test)

print ("the accuracy score for the model is ", accuracy_score(y_test, y_pred.argmax(axis=1)))

y_pred

y_test

print (classification_report(y_test, y_pred.argmax(axis=1)))

plt.figure(figsize=(15,10))
sns.heatmap(confusion_matrix(y_test,y_pred.argmax(axis=1)),annot=True,fmt='g')
plt.title("confusion matrix for CNN Model")
plt.show()

predictions = model.predict(x_test[0].reshape(1,64,64,3))

plt.figure(figsize=(10,5))
plt.subplot(1,2,1)
plt.imshow(x_test[0])
plt.title(f"the original class {y_test[0]}")
plt.subplot(1,2,2)
plt.imshow(x_test[0])
plt.title(f"predicted class {predictions.argmax(axis=1)}")
plt.show()

model.save_weights('my_model.weights.h5')

model.save('my_model.h5')

from google.colab import files
files.download('my_model.h5')